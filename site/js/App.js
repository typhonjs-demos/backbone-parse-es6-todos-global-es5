/**
 * Backbone-Parse Global TODOS example -- Provides the canonical TODOS web app using the global ES5 bundle
 * generated by backbone-parse-es6 (https://github.com/typhonjs-parse/backbone-parse-es6). This is a rhetorical demo
 * showing how to consume the library in a global JS context. This is absolutely _NOT_ the recommended way to consume
 * backbone-parse-es6, but gives an example for those converting from global usage to JSPM / SystemJS. Please see
 * backbone-parse-es6-todos (https://github.com/typhonjs-demos/backbone-parse-es6-todos) for the recommended way to
 * work with backbone-parse-es6 and JSPM / SystemJS.
 */
$(function()
{
   /**
    * Initialize Parse with the app id / key.
    */
   Parse.initialize('prBNuyKHlwbX4wvWTUNNWY5GaQLI7cAZ96pd5RwM', 'YyaqHxgLUNMn4Ito5sokU1o8g0exPbJcsUMKZSQB');

   /**
    * Creates a global eventbus for various parts of the app to communicate indirectly rather than invoking direct
    * methods. In particular this allows Views to call functions of the main App.
    */
   var eventbus = new Backbone.Events();

   // Models --------------------------------------------------------------------------------------------------------

   /**
    * This is the transient application state, not persisted on Parse. By using a `Backbone.Model` this also makes it an
    * instance of `Backbone.Events` allowing subscription to state changes. An instance of AppState created after
    * definition allows any other subsequent code to access this instance.
    */
   var AppState = Backbone.Model.extend('AppState',
   {
      /**
       * Default value for AppState which is set in `Backbone.Model` when initializing an instance of `AppState`.
       */
      defaults: { filter: 'all' }
   });

   /**
    * Create global appState reference shared between router, views and main app.
    */
   var appState = new AppState();

   /**
    * Our basic todos Item model has `content`, `order`, and `done` attributes. When creating a new Item instance in
    * `App->createItem` the current Parse user is also associated with the item instance along with a
    * Parse.ACL (access control list) instance which ensures that the item is only accessible by that given user.
    */
   var Item = Backbone.Model.extend('Item',
   {
      /**
       * Default attributes for the item.
       */
      defaults:
      {
         content: 'empty todo...',
         done: false
      },

      /**
       * Ensure that each item created has `content`.
       */
      initialize: function()
      {
         if (!this.get('content'))
         {
            this.set({ 'content': this.defaults.content });
         }
      },

      /**
       * Toggle the `done` state of this item.
       */
      toggle: function()
      {
         this.save({ done: !this.get('done') });
      }
   });

   // Collections ---------------------------------------------------------------------------------------------------

   /**
    * This module defines a `Backbone.Collection` which stores todos `Items` and provides utility methods to filter,
    * sort and retrieve the next order number used to sort `Items`. An single shared instance of TodoList is created
    * right after definition below. This allows the instance to be used anywhere the collection is necessary.
    * Multiple views may access this instance, but in this demo only `ManageTodosView` displays data from the
    * collection.
    *
    * Please note that the Parse.Query is generated in `App->showTodos` during user login using the current user ID to
    * retrieve `Items` associated with the current user.
    */
   var TodoList = Backbone.Collection.extend(
   {
      /**
       * Reference to this collection's model.
       */
      model: Item,

      /**
       * Todos are sorted by their original insertion order.
       *
       * @param {Item} item - item model.
       * @returns {number}
       */
      comparator: function(item)
      {
         return item.get('order');
      },

      /**
       * Filter down the list of all todos items that are finished.
       *
       * @returns {*}
       */
      done: function()
      {
         return this.filter(function(item) { return item.get('done'); });
      },

      /**
       * We keep the todos Items in sequential order, despite being saved by unordered GUID in the database. This
       * generates the next order number for new items.
       *
       * @returns {number}
       */
      nextOrder: function()
      {
         if (!this.length) { return 1; }
         return this.last().get('order') + 1;
      },

      /**
       * Filter down the list to only todos items that are still not finished.
       *
       * @returns {*}
       */
      remaining: function()
      {
         return this.without.apply(this, this.done());
      }
   });

   /**
    * Create global todoList reference shared between views and main app.
    */
   var todoList = new TodoList();

   // Router --------------------------------------------------------------------------------------------------------

   /**
    * Provides a basic `Backbone.Router` to route between app states: `all`, `active` & `completed`. When a user
    * navigates between these different filter type states `Backbone.history.navigate` is invoked in
    * `App->selectFilter` to update the navigation history allowing the user to use the back and forward browser
    * controls to navigate the app. When a filter type is selected it is referenced in the current URL for the web app.
    * If this URL is navigated to and the user is still logged into the app `AppRouter` will set the `AppState`
    * accordingly and `ManageTodosView` will appropriately show the `Items` for the current user given the filter state
    * set below. If a user is not logged in `App` renders the login view and `AppRouter` will replace any route
    * matches with no hash tag.
    *
    * Please note that in the `App constructor` a default catch all no route callback is specified which handles
    * unmatched routes.
    */
   var AppRouter = Backbone.Router.extend(
   {
      /**
       * Creates the routes delegated to the given methods specified.
       */
      routes:
      {
         'all': 'all',
         'active': 'active',
         'completed': 'completed'
      },

      /**
       * Handles the `all` route. If the user is logged in then `appState` is set to `all` otherwise the route is
       * replaced in the browser history with no route.
       */
      all: function()
      {
         if (Parse.User.current() !== null)
         {
            appState.set({ filter: 'all' });
         }
         else
         {
            Backbone.history.navigate('', { replace: true });
         }
      },

      /**
       * Handles the `active` route. If the user is logged in then `appState` is set to `active` otherwise the route is
       * replaced in the browser history with no route.
       */
      active: function()
      {
         if (Parse.User.current() !== null)
         {
            appState.set({ filter: 'active' });
         }
         else
         {
            Backbone.history.navigate('', { replace: true });
         }
      },

      /**
       * Handles the `completed` route. If the user is logged in then `appState` is set to `completed` otherwise the
       * route is replaced in the browser history with no route.
       */
      completed: function()
      {
         if (Parse.User.current() !== null)
         {
            appState.set({ filter: 'completed' });
         }
         else
         {
            Backbone.history.navigate('', { replace: true });
         }
      }
   });

   // Views ---------------------------------------------------------------------------------------------------------

   /**
    * The `Backbone.View` for an item which encapsulates the ability to edit the content of the item. With a desktop
    * browser an `Item` can be edited with a double click or double tap when running on a mobile device. In this case
    * additional jQuery events including `doubletap` are loaded via the jQuery finger
    * plugin (http://ngryman.sh/jquery.finger/).
    */
   var ItemView = Backbone.View.extend(
   {
      /**
       * Defines the tag that is created for an `Item`.
       */
      tagName: 'li',

      /**
       * Delegated events for interacting with an `Item`.
       */
      events:
      {
         'click .toggle': 'toggleDone',
         'dblclick label.todo-content': 'edit',
         'doubletap label.todo-content': 'edit',
         'click .todo-destroy': 'clear',
         'keypress .edit': 'updateOnEnter',
         'blur .edit': 'closeEdit'
      },

      /**
       * Cache the template function for a single item.
       */
      template: _.template($('#template-item').html()),

      /**
       * The ItemView listens for changes to its model, re-rendering. Since there's a one-to-one correspondence between
       * an Item and an ItemView. If the model is deleted then the `Backbone.View->remove` method is invoked.
       */
      initialize: function()
      {
         // Binds the `this` context to all methods such that it is accessible via Backbone event callbacks.
         _.bindAll(this, 'clear', 'closeEdit', 'remove', 'render');

         this.listenTo(this.model, 'change', this.render);
         this.listenTo(this.model, 'destroy', this.remove);
      },

      /**
       * Remove the item, destroy the model.
       */
      clear: function()
      {
         this.model.destroy();
      },

      /**
       * Close the `editing` mode, saving changes to the item.
       */
      closeEdit: function()
      {
         this.model.save({ content: this.input.val() });
         this.$el.removeClass('editing');
      },

      /**
       * Switch this view into `editing` mode, displaying the input field.
       */
      edit: function()
      {
         this.$el.addClass('editing');
         this.input.focus();
      },

      /**
       * Re-render the contents of the Item.
       *
       * @returns {ItemView}
       */
      render: function()
      {
         this.$el.html(this.template(this.model.toJSON()));

         /**
          * @type {object} Stores the edit input.
          */
         this.input = this.$('.edit');

         return this;
      },

      /**
       * Toggle the `done` state of the model.
       */
      toggleDone: function()
      {
         this.model.toggle();
      },

      /**
       * If you hit `enter`, we're through editing the item.
       *
       * @param {object}   e - event data
       */
      updateOnEnter: function(e)
      {
         if (e.keyCode === 13) { this.closeEdit(); }
      }
   });


   /**
    * Provides a `Backbone.View` allowing a user to login or sign up.
    */
   var LogInView = Backbone.View.extend(
   {
      /**
       * Sets the element this view is associated with to `.content`.
       */
      el: '.content',

      /**
       * Delegated events for logging in and signing up.
       */
      events:
      {
         'submit form.login-form': 'logIn',
         'submit form.signup-form': 'signUp'
      },

      /**
       * Binds `this` to the methods specified and renders the view.
       */
      initialize: function()
      {
         // Binds the `this` context to all methods such that it is accessible via Backbone event callbacks.
         _.bindAll(this, 'logIn', 'signUp');

         this.render();
      },

      /**
       * Attempts to login a user and on success dispatches a `app:user:login` event which is handled in `App`
       * controlling view management.
       *
       * @param {object}   e - event data
       */
      logIn: function(e)
      {
         // When dealing with a form submit button it's necessary to prevent the default form submission.
         e.preventDefault();

         const username = this.$('#login-username').val();
         const password = this.$('#login-password').val();

         var self = this;

         // Send an event `app:user:login` on successful login.
         Parse.User.logIn(username, password).then(function()
         {
            eventbus.trigger('app:user:login');
         },
         function()
         {
            self.$('.login-form .error').html('Invalid username or password. Please try again.').show('fast');

            // Hide the error message and enable the login button.
            setTimeout(function()
            {
               self.$('.login-form .error').hide('fast');
               self.$('.login-form button').prop('disabled', false);
            }, 3000);
         });

         // Always set the login button to disabled. If there is an error the button is enabled again.
         this.$('.login-form button').prop('disabled', true);
      },

      /**
       * Renders the login view.
       */
      render: function()
      {
         // Set the `.content` element to the login template.
         this.$el.html(_.template($('#template-login').html()));

         // Automatically wires all events specified by `get events()`.
         this.delegateEvents();
      },

      /**
       * Attempts to sign up a user and on success dispatches a `app:user:login` event which is handled in `App`
       * controlling view management.
       *
       * @param {object}   e - event data
       */
      signUp: function(e)
      {
         // When dealing with a form submit button it's necessary to prevent the default form submission.
         e.preventDefault();

         const username = this.$('#signup-username').val();
         const password = this.$('#signup-password').val();

         var self = this;

         // Dispatch the `app:user:login` on successful signup.
         Parse.User.signUp(username, password, { ACL: new Parse.ACL() }).then(function()
         {
            eventbus.trigger('app:user:login');
         },
         function(error)
         {
            self.$('.signup-form .error').html(_.escape(error.message)).show('fast');

            // Hide the error message and enable the sign up button.
            setTimeout(function()
            {
               self.$el.find('.signup-form .error').hide('fast');
               self.$('.signup-form button').prop('disabled', false);
            }, 3000);
         });

         // Always set the sign up button to disabled. If there is an error the button is enabled again.
         this.$('.signup-form button').prop('disabled', true);
      }
   });


   /**
    * The main view that lets a user manage their todos `Items`. When the various items are rendered they are tracked
    * in the `itemViews` object hash so that they can be cleaned up correctly.
    */
   var ManageTodosView = Backbone.View.extend(
   {
      el: '.content',

      /**
       * Delegated events for creating new items and clearing completed ones.
       */
      events:
      {
         'keypress #new-todo': 'createOnEnter',
         'click #clear-completed': 'clearCompleted',
         'click #toggle-all': 'toggleAllComplete',
         'click .log-out': function() { eventbus.trigger('app:user:logout'); },
         'click ul#filters a': function(e) { eventbus.trigger('app:select:filter', $(e.target).attr('id')); }
      },

      /**
       * The template for the line of statistics at the bottom of the app.
       */
      statsTemplate: _.template($('#template-stats').html()),

      /**
       * At initialization we bind to the relevant events on the `Todos` collection, when items are added or changed.
       * Kick things off by loading any preexisting todos that might be saved to Parse.
       *
       * @param {object}   options - optional parameters
       */
      initialize: function(options)
      {
         this.itemViews = {};

         // Binds the `this` context to all methods such that it is accessible via Backbone event callbacks.
         _.bindAll(this, 'addOne', 'addAll', 'addSome', 'createOnEnter', 'render', 'toggleAllComplete');

         // Main todos management template.
         this.$el.html(_.template($('#template-manage-todos').html())(options));

         /**
          * @type {object} Stores the input field.
          */
         this.input = this.$('#new-todo');

         /**
          * @type {object} Stores the toggle all checkbox.
          */
         this.allCheckbox = this.$('#toggle-all')[0];

         var self = this;

         // Useful to get rid of the initial displayed spinner gif. This is called only once when the collection
         // initially is reset.
         this.listenToOnce(todoList, 'reset', function() { self.$('#todo-list').html(''); });

         // When `AppState` changes invoke `filter` to redraw this view.
         this.listenTo(appState, 'change', this.filter);

         // When `todoList` is reset / initially populated or if an Item done state changes invoke `filter` to
         // redraw this view.
         this.listenTo(todoList, 'change:done reset', this.filter);

         // Ensure that the statistics are re-rendered when an item is added or removed.
         this.listenTo(todoList, 'update', this.render);
      },

      /**
       * Add all items in the Todos collection at once.
       */
      addAll: function()
      {
         this.clearAll();

         todoList.each(this.addOne);

         this.render();
      },

      /**
       * Add a single item to the list by creating a view for it, and appending its element to the `<ul>`.
       *
       * @param {Item}  item - Item to add.
       */
      addOne: function(item)
      {
         var view = new ItemView({ model: item });

         this.itemViews[item] = view;

         this.$('#todo-list').append(view.render().el);
      },

      /**
       * Only adds some todos, based on a filtering function that is passed into `addSome`.
       *
       * @param {function} filter - A function to filter the Items.
       */
      addSome: function(filter)
      {
         this.clearAll();

         todoList.chain().filter(filter).each(this.addOne);

         this.render();
      },

      /**
       * Iterates through the `itemViews` invoking the `Backbone.View->remove` method for each `ItemView` tracked.
       * The object hash is then cleared.
       */
      clearAll: function()
      {
         this.$('#todo-list').html('');

         _.each(this.itemViews, function(itemView)
         {
            itemView.remove();
         });

         this.itemViews = {};
      },

      /**
       * Clear all done todos items, destroying their models.
       */
      clearCompleted: function()
      {
         var self = this;

         _.each(todoList.done(), function(item)
         {
            // This will trigger the remove method of ItemView.
            item.destroy();

            // Remove the ItemView from the tracking map.
            delete self.itemViews[item];
         });
      },

      /**
       * If you hit return in the main input field, create new Item model. The creation of the item is handled over
       * the eventbus via triggering `app:create:item` which invokes `App->createItem`.
       *
       * @param {object}   e - event data
       */
      createOnEnter: function(e)
      {
         // Only respond to `enter` pressed.
         if (e.keyCode !== 13) { return; }

         // Create new item.
         eventbus.trigger('app:create:item', this.input.val());

         // Clear the input text field.
         this.input.val('');

         // Sets state and updates Backbone.history.navigate.
         eventbus.trigger('app:select:filter', 'all');
      },

      /**
       * Invoked when the TodoList collection is reset and when the app state changes.
       */
      filter: function()
      {
         var filterValue = appState.get('filter');

         switch(filterValue)
         {
            case 'all':
               this.addAll();
               break;

            case 'completed':
               this.addSome(function(item) { return item.get('done'); });
               break;

            default:
               this.addSome(function(item) { return !item.get('done'); });
               break;
         }
      },

      /**
       * Re-rendering the App just means refreshing the statistics -- the rest of the app doesn't change.
       */
      render: function()
      {
         var done = todoList.done().length;
         var remaining = todoList.remaining().length;

         // Render the statistics template
         this.$('#todo-stats').html(this.statsTemplate({ total: todoList.length, done: done, remaining: remaining }));

         // Automatically wires all events specified by `get events()`.
         this.delegateEvents();

         // Sets the checked state of the allCheckbox depending on remaining count.
         this.allCheckbox.checked = !remaining;

         // Update the filter state after the stats template is rendered.
         var filterValue = appState.get('filter');
         $('ul#filters a').removeClass('selected');
         $('ul#filters a#' + filterValue).addClass('selected');
      },

      /**
       * Toggles all todos items to completed / done then saves each item.
       */
      toggleAllComplete: function()
      {
         var done = this.allCheckbox.checked;
         todoList.each(function(item) { item.save({ done: done }); });
      }
   });

// ----------------------------------

   /**
    * Provides the main entry point for the Todos app and major control functionality (the C in MVC). This control
    * functionality is exposed over an eventbus created by `eventbus` defined at the top of this file.
    *
    * It should be noted that since this app is based on `backbone-parse-es6` there are no additional lifecycle methods
    * added to Backbone.View such as `close` which automatically removes all listeners defined by `listenTo`. Each view
    * must explicitly have any listeners removed before creating a new view.
    *
    * While in this simple app there is only one view of the `TodoList` a benefit of separating control functionality
    * and the `TodoList` instance from a specific view is that it could be used across multiple views.
    */
   function App()
   {
      /**
       * Creates a new Item in the todos list. Note the addition of user which becomes a Parse pointer and an
       * Parse.ACL (access control list) which limits the item to be only accessible to the current user.
       *
       * @param {string}   content - The text for the item.
       */
      this.createItem = function(content)
      {
         var user = Parse.User.current();

         // Ensure that content is a string and there is a currently logged in user. If so then create a new
         // `Item` entry in `todoList`.
         if (typeof content === 'string' && user !== null)
         {
            todoList.create(
             {
                content: content,
                order: todoList.nextOrder(),
                done: false,
                user: user,                      // Current user is assigned as a pointer.
                ACL: new Parse.ACL(user)   // An ACL with the current user ensures that it is only accessible by this user.
             });
         }
      };

      /**
       * Invokes `showTodos` if there is a current user.
       */
      this.logInUser = function()
      {
         var user = Parse.User.current();
         if (user !== null)
         {
            this.showTodos(user.escape('username'));
         }
      };

      /**
       * Logs out the user and shows the login view.
       */
      this.logOutUser = function()
      {
         var self = this;

         // Close any current view and create the LogInView on success.
         Parse.User.logOut().then(function()
         {
            if (self.currentView)
            {
               self.currentView.stopListening();
               self.currentView.off();
               self.currentView.undelegateEvents();

               // Removes any child views.
               if (self.currentView.clearAll)
               {
                  self.currentView.clearAll();
               }

               delete self.currentView;
            }
            self.currentView = new LogInView();
            appState.set('filter', 'all');
         });
      };

      /**
       * Sets the app state with the new filter type and updates `Backbone.History`.
       *
       * @param {string}   filter - Filter type to select.
       */
      this.selectFilter = function(filter)
      {
         // When setting a value on a `Backbone.Model` if the value is the same as what is being set a change event will
         // not be fired. In this case we set the new state with the `silent` option which won't fire any events then
         // we manually trigger a change event so that any listeners respond regardless of the original state value.
         appState.set({ filter: filter }, { silent: true });
         appState.trigger('change', appState);

         // Update the history state with the new filter type.
         Backbone.history.navigate(filter);
      };

      /**
       * Creates and shows a new ManageTodosView then sets a new `Parse.Query` for `todoList` for the current user and
       * fetches the collection.
       *
       * @param {string}   username - Name of current user.
       * @returns {*}
       */
      this.showTodos = function(username)
      {
         if (this.currentView)
         {
            this.currentView.stopListening();
            this.currentView.off();
            this.currentView.undelegateEvents();
            delete this.currentView;
         }

         Backbone.history.navigate(appState.get('filter'), { replace: true });

         // Create a new ManageTodosView and pass in the username via optional parameters. In a Backbone.View additional
         // options are available via `this.options.<key>`.
         this.currentView = new ManageTodosView({ username: username });

         // Set the `todoList` query which is necessary for Parse backed collections. The `equalTo` qualifier returns
         // items that are associated with the current user.
         todoList.query = new Parse.Query(todoList.model);
         todoList.query.equalTo('user', Parse.User.current());

         // Fetch all the todos items for this user. Any listeners for `todoList` reset events will be invoked.
         todoList.fetch({ reset: true });

         return this.currentView;
      };

      // Wires up the main eventbus allowing Views to invoke App functions indirectly.
      eventbus.on('app:create:item', this.createItem, this);
      eventbus.on('app:select:filter', this.selectFilter, this);
      eventbus.on('app:user:login', this.logInUser, this);
      eventbus.on('app:user:logout', this.logOutUser, this);

      // Initialize the `AppRouter` and set up a catch all handler then invokes `Backbone.history.start` with the root
      // path of the App.
      new AppRouter();

      // Defines a catch all handler for all non-matched routes (anything that isn't `all`, `active` or `completed`). If
      // a user is logged in the catch all navigates to `all` triggering the route and replacing the invalid route in
      // the browser history.
      Backbone.history.handlers.push(
      {
         route: /(.*)/,
         callback: function()
         {
            if (Parse.User.current() !== null)
            {
               Backbone.history.navigate('all', { trigger: true, replace: true });
            }
            else
            {
               Backbone.history.navigate('', { replace: true });
            }
         }
      });

      // This regex matches the root path, so that it can be set in `Backbone.history.start`
      var root, urlMatch;

      // Construct the root path to the web app which is the path above the domain that may include `index.html` or
      // `indexSrc.html` depending on the runtime. For instance in WebStorm when creating a local server `index.html` is
      // included in the URL. Running on an actual web server often `index.html` is not put into the URL. When running
      // the app from source code transpiled in the browser `indexSrc.html` is always in the URL.
      if (typeof window.location !== 'undefined')
      {
         const windowLocation = window.location.toString();

         if (windowLocation.includes('.html'))
         {
            urlMatch = windowLocation.match(/\/\/[\s\S]*\/([\s\S]*\/)([\s\S]*\.html)/i);
            root = urlMatch && urlMatch.length >= 3 ? '' + urlMatch[1] + urlMatch[2] : undefined;
         }
         else
         {
            urlMatch = windowLocation.match(/\/\/[\s\S]*\/([\s\S]*\/)/i);
            root = urlMatch && urlMatch.length >= 2 ? urlMatch[1] : undefined;
         }
      }

      Backbone.history.start({ root: root });

      // -----

      // Get the current user and show the proper initial view given whether a user is currently logged in to the app.
      var user = Parse.User.current();

      /**
       * Creates the initial displayed view based given if a user is currently logged into the app.
       *
       * @type {View} Stores the current active view.
       */
      this.currentView = user !== null ? this.showTodos(user.escape('username')) : new LogInView();
   }

   // Initialize and create a new App instance.
   new App();
});